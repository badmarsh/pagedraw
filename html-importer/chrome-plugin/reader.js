// Generated by CoffeeScript 1.10.0
(function() {
  var DEBUG, blocks, clientRect, colorIsVisible, getCSSValueUrl, hasVisibleText, isOffscreen, numOfPx, output, relativeNumOfPx, urlpath;

  numOfPx = function(str) {
    if ((str != null) === false || !str.endsWith('px')) {
      console.log("failed to get size of " + str);
      return void 0;
    }
    return Number(str.slice(0, -2));
  };

  relativeNumOfPx = function(str, basisSize) {
    var pct;
    if (!(str != null ? str.endsWith('%') : void 0)) {
      return numOfPx(str);
    }
    pct = Number(str.slice(0, -1));
    return 0.01 * pct * basisSize;
  };

  colorIsVisible = function(str) {
    var a, b, g, r, ref, ref1, ref2, ref3, rgb_match, rgba_match;
    if ((str != null) === false) {
      return false;
    }
    str = str.replace(/\s*/g, '');
    if (rgba_match = (ref = /rgba\((\d+),(\d+),(\d+),(\d+)\)/.exec(str)) != null ? (ref1 = ref.slice(1)) != null ? ref1.map(Number) : void 0 : void 0) {
      r = rgba_match[0], g = rgba_match[1], b = rgba_match[2], a = rgba_match[3];
    } else if (rgb_match = (ref2 = /rgb\((\d+),(\d+),(\d+)\)/.exec(str)) != null ? (ref3 = ref2.slice(1)) != null ? ref3.map(Number) : void 0 : void 0) {
      r = rgb_match[0], g = rgb_match[1], b = rgb_match[2];
      a = 1;
    } else {
      return true;
    }
    if (a === 0) {
      return false;
    }
    return true;
  };

  getCSSValueUrl = function(cssvalue) {
    var i, len, p, patterns, ref, url;
    if (cssvalue == null) {
      return void 0;
    }
    patterns = [/url\('(.*)'\)/, /url\("(.*)"\)/];
    for (i = 0, len = patterns.length; i < len; i++) {
      p = patterns[i];
      url = (ref = p.exec(cssvalue)) != null ? ref[1] : void 0;
      if (url != null) {
        return url;
      }
    }
    return void 0;
  };

  clientRect = function(domnode) {
    var r;
    r = new Range();
    r.selectNode(domnode);
    return r.getBoundingClientRect();
  };

  isOffscreen = function(rect) {
    return rect.left < 0 || rect.bottom < 0;
  };

  hasVisibleText = function(dom) {
    return (dom.nodeType === Node.TEXT_NODE && !isOffscreen(clientRect(dom))) || _.any(dom.childNodes, hasVisibleText);
  };

  DEBUG = true;

  if (DEBUG != null) {
    urlpath = document.location.href;
  } else {
    urlpath = document.location.pathname;
  }

  blocks = $("*").toArray().map($).map(function(domBlock) {
    var block, btype, height, left, ref, ref1, ref2, ref3, styles, top, width;
    styles = window.getComputedStyle(domBlock[0]);
    ref = domBlock.offset(), top = ref.top, left = ref.left;
    top += numOfPx(styles.paddingTop) + numOfPx(styles.borderTopWidth);
    left += numOfPx(styles.paddingLeft) + numOfPx(styles.borderLeftWidth);
    ref1 = [domBlock.height(), domBlock.width()], height = ref1[0], width = ref1[1];
    ref2 = [top, left, height, width].map(Math.round), top = ref2[0], left = ref2[1], height = ref2[2], width = ref2[3];
    if (domBlock.is(':visible') === false || !(height > 0 && width > 0) || styles.display === 'none' || styles.visibility === 'hidden') {
      return null;
    }
    btype = 'layout';
    block = {
      top: top,
      left: left,
      height: height,
      width: width,
      "color": styles.backgroundColor,
      "image": getCSSValueUrl(styles.backgroundImage),
      "borderRadius": relativeNumOfPx(styles.borderRadius, height)
    };
    if (((ref3 = domBlock.children()) != null ? ref3.length : void 0) === 0 && domBlock.text() && hasVisibleText(domBlock[0])) {
      btype = 'text';
      block.htmlContent = domBlock.html();
      block.fontColor = styles.color;
      block.fontSize = numOfPx(styles.fontSize);
      block.fontFamily = styles.fontFamily;
      block.textAlign = styles.textAlign;
      block.lineHeight = numOfPx(styles.lineHeight);
    } else if (domBlock[0].tagName === 'IMG' && (domBlock[0].src != null)) {
      btype = 'image';
      block.url = domBlock[0].src;
    } else if (!colorIsVisible(block.color) && (block.image == null)) {
      return null;
    }
    block.__ty = "/block/" + btype;
    return block;
  });

  blocks = blocks.filter(function(b) {
    return b !== null;
  });

  output = function(json) {
    return chrome.extension.sendMessage(json);
  };

  output({
    url: urlpath,
    blocks: blocks
  });

  console.log("content imported");

}).call(this);

//# sourceMappingURL=reader.js.map
